module;

export module eco:algorithm;

import std;
import :concepts;
import :iterator;

namespace eco::inline cpp23 {

struct fold_left_nonempty_impl
{
  template <std::ranges::input_range R, typename Op, typename Proj = std::identity>
  requires indirectly_regular_binary_invocable<Op, std::projected<std::ranges::iterator_t<R>, Proj>>
  [[nodiscard]] constexpr auto
  operator()(R&& r, Op op, Proj proj = {}) const
  {
    return (*this)(std::ranges::begin(r), std::ranges::end(r), std::ref(op), std::ref(proj));
  }

  template <std::input_iterator I, typename Op, typename Proj = std::identity>
  requires indirectly_regular_binary_invocable<Op, std::projected<I, Proj>>
  [[nodiscard]] constexpr auto
  operator()(I first, std::sentinel_for<I> auto last, Op op, Proj proj = {}) const
  {
    auto result{std::invoke(proj, *first)};
    ++first;
    while (first != last) {
      result = std::invoke(op, std::move(result), std::invoke(proj, *first));
      ++first;
    }
    return result;
  }
};

export inline constexpr fold_left_nonempty_impl fold_left_nonempty{};

struct fold_right_nonempty_impl
{
  template <std::ranges::bidirectional_range R, typename Op, typename Proj = std::identity>
  requires indirectly_regular_binary_invocable<Op, std::projected<std::ranges::iterator_t<R>, Proj>>
  [[nodiscard]] constexpr auto
  operator()(R&& r, Op op, Proj proj = {}) const
  {
    return (*this)(std::ranges::begin(r), std::ranges::end(r), std::ref(op), std::ref(proj));
  }

  template <std::bidirectional_iterator I, typename Op, typename Proj = std::identity>
  requires indirectly_regular_binary_invocable<Op, std::projected<I, Proj>>
  [[nodiscard]] constexpr auto
  operator()(I first, std::sentinel_for<I> auto last, Op op, Proj proj = {}) const
  {
    auto tail = std::ranges::next(first, last);
    --tail;
    auto result{std::invoke(proj, *tail)};
    while (first != tail) {
      --tail;
      result = std::invoke(op, std::invoke(proj, *tail), std::move(result));
    }
    return result;
  }
};

export inline constexpr fold_right_nonempty_impl fold_right_nonempty{};

struct fold_left_impl
{
  template <typename Op, typename I, typename Proj>
  using result_t = std::indirect_result_t<Op, std::projected<I, Proj>, std::projected<I, Proj>>;

  template
  <
    std::ranges::input_range R,
    typename Op,
    typename Proj = std::identity
  >
  requires
    indirectly_regular_binary_invocable
    <
      Op,
      std::projected<std::ranges::iterator_t<R>, Proj>
    > &&
    std::movable<result_t<Op, std::ranges::iterator_t<R>, Proj>>
  [[nodiscard]] constexpr auto
  operator()(R&& r, result_t<Op, std::ranges::iterator_t<R>, Proj> id, Op op, Proj proj = {}) const
  {
    return (*this)(std::ranges::begin(r), std::ranges::end(r), std::move(id), std::ref(op), std::ref(proj));
  }

  template
  <
    std::input_iterator I,
    typename Op,
    typename Proj = std::identity
  >
  requires
    indirectly_regular_binary_invocable<Op, std::projected<I, Proj>> &&
    std::movable<result_t<Op, I, Proj>>
  [[nodiscard]] constexpr auto
  operator()(I first, std::sentinel_for<I> auto last, result_t<Op, I, Proj> id, Op op, Proj proj = {}) const
  {
    if (first == last) return id;
    return fold_left_nonempty(first, last, std::ref(op), std::ref(proj));
  }
};

export inline constexpr fold_left_impl fold_left{};

struct fold_right_impl
{
  template <typename Op, typename I, typename Proj>
  using result_t = std::indirect_result_t<Op, std::projected<I, Proj>, std::projected<I, Proj>>;

  template <std::ranges::bidirectional_range R, typename Op, typename Proj = std::identity>
  requires
    indirectly_regular_binary_invocable
    <
      Op,
      std::projected<std::ranges::iterator_t<R>, Proj>
    > &&
    std::movable<result_t<Op, std::ranges::iterator_t<R>, Proj>>
  [[nodiscard]] constexpr auto
  operator()(R&& r, result_t<Op, std::ranges::iterator_t<R>, Proj> id, Op op, Proj proj = {}) const
  {
    return (*this)(std::ranges::begin(r), std::ranges::end(r), std::move(id), std::ref(op), std::ref(proj));
  }

  template <std::bidirectional_iterator I, typename Op, typename Proj = std::identity>
  requires
    indirectly_regular_binary_invocable<Op, std::projected<I, Proj>> &&
    std::movable<result_t<Op, I, Proj>>
  [[nodiscard]] constexpr auto
  operator()(I first, std::sentinel_for<I> auto last, result_t<Op, I, Proj> id, Op op, Proj proj = {}) const
  {
    if (first == last) return id;
    return fold_right_nonempty(first, last, std::ref(op), std::ref(proj));
  }
};

export inline constexpr fold_right_impl fold_right{};

struct fold_binary_left_nonempty_impl
{
  template
  <
    std::ranges::input_range R1,
    std::ranges::input_range R2,
    typename Op1,
    typename Op2,
    typename Proj1 = std::identity,
    typename Proj2 = std::identity
  >
  requires
    std::regular_invocable
    <
      Op1,
      std::invoke_result_t<Op2, projected_range_value_t<R1, Proj1>, projected_range_value_t<R2, Proj2>>,
      std::invoke_result_t<Op2, projected_range_value_t<R1, Proj2>, projected_range_value_t<R2, Proj2>>
    > &&
    indirectly_regular_binary_invocable
    <
      Op2,
      std::projected<std::ranges::iterator_t<R1>, Proj1>,
      std::projected<std::ranges::iterator_t<R2>, Proj2>
    >
  [[nodiscard]] constexpr auto
  operator()(R1&& r1, R2&& r2, Op1 op1, Op2 op2, Proj1 proj1 = {}, Proj2 proj2 = {}) const
  {
    // pre axiom: "r1 and r2 are non-empty and length of r2 >= length of r1"

    return (*this)(std::ranges::begin(r1), std::ranges::end(r1), std::ranges::begin(r2), std::ref(op1), std::ref(op2), std::ref(proj1), std::ref(proj2));
  }

  template
  <
    std::input_iterator I1,
    std::sentinel_for<I1> S1,
    std::input_iterator I2,
    typename Op1,
    typename Op2,
    typename Proj1 = std::identity,
    typename Proj2 = std::identity
  >
  [[nodiscard]] constexpr auto
  operator()(I1 first1, S1 last1, I2 first2, Op1 op1, Op2 op2, Proj1 proj1 = {}, Proj2 proj2 = {}) const
  requires
    std::regular_invocable
    <
      Op1,
      std::invoke_result_t<Op2, projected_value_t<I1, Proj1>, projected_value_t<I2, Proj2>>,
      std::invoke_result_t<Op2, projected_value_t<I1, Proj1>, projected_value_t<I2, Proj2>>
    > &&
    indirectly_regular_binary_invocable
    <
      Op2,
      std::projected<I1, Proj1>,
      std::projected<I2, Proj2>
    >
  {
    // pre axiom: first1 != last1 && "first2 denotes the start of a range of length >= length of [first1, last1)"

    auto result = std::invoke(op2, std::invoke(proj1, *first1), std::invoke(proj2, *first2));
    ++first1;
    ++first2;
    while (first1 != last1) {
      result = std::invoke(op1, result, std::invoke(op2, std::invoke(proj1, *first1), std::invoke(proj2, *first2)));
      ++first1;
      ++first2;
    }
    return result;
  }
};

export inline constexpr fold_binary_left_nonempty_impl fold_binary_left_nonempty{};

struct fold_binary_left_impl
{
  template <typename Op1, typename Op2, typename I1, typename I2, typename Proj1, typename Proj2>
  using result_t =
    std::invoke_result_t
    <
      Op1,
      std::invoke_result_t<Op2, projected_value_t<I1, Proj1>, projected_value_t<I2, Proj2>>,
      std::invoke_result_t<Op2, projected_value_t<I1, Proj1>, projected_value_t<I2, Proj2>>
    >;

  template
  <
    std::ranges::input_range R1,
    std::ranges::input_range R2,
    typename Op1,
    typename Op2,
    typename Proj1 = std::identity,
    typename Proj2 = std::identity
  >
  requires
    std::regular_invocable
    <
      Op1,
      std::invoke_result_t<Op2, projected_range_value_t<R1, Proj1>, projected_range_value_t<R2, Proj2>>,
      std::invoke_result_t<Op2, projected_range_value_t<R1, Proj2>, projected_range_value_t<R2, Proj2>>
    > &&
    indirectly_regular_binary_invocable
    <
      Op2,
      std::projected<std::ranges::iterator_t<R1>, Proj1>,
      std::projected<std::ranges::iterator_t<R2>, Proj2>
    > &&
    std::movable
    <
      result_t
      <
        Op1,
        Op2,
        std::ranges::iterator_t<R1>,
        std::ranges::iterator_t<R2>,
        Proj1,
        Proj2
      >
    >
  [[nodiscard]] constexpr auto
  operator()(
    R1&& r1,
    R2&& r2,
    result_t<Op1, Op2, std::ranges::iterator_t<R1>, std::ranges::iterator_t<R2>, Proj1, Proj2> id,
    Op1 op1,
    Op2 op2,
    Proj1 proj1 = {},
    Proj2 proj2 = {}
  ) const
  {
    return (*this)(std::ranges::begin(r1), std::ranges::end(r1), std::ranges::begin(r2), std::move(id), std::ref(op1), std::ref(op2), std::ref(proj1), std::ref(proj2));
  }

  template
  <
    std::input_iterator I1,
    std::sentinel_for<I1> S1,
    std::input_iterator I2,
    typename Op1,
    typename Op2,
    typename Proj1 = std::identity,
    typename Proj2 = std::identity
  >
  [[nodiscard]] constexpr auto
  operator()(I1 first1, S1 last1, I2 first2, result_t<Op1, Op2, I1, I2, Proj1, Proj2> id, Op1 op1, Op2 op2, Proj1 proj1 = {}, Proj2 proj2 = {}) const
  requires
    std::regular_invocable
    <
      Op1,
      std::invoke_result_t<Op2, projected_value_t<I1, Proj1>, projected_value_t<I2, Proj2>>,
      std::invoke_result_t<Op2, projected_value_t<I1, Proj1>, projected_value_t<I2, Proj2>>
    > &&
    indirectly_regular_binary_invocable
    <
      Op2,
      std::projected<I1, Proj1>,
      std::projected<I2, Proj2>
    > &&
    std::movable<result_t<Op1, Op2, I1, I2, Proj1, Proj2>>
  {
    if (first1 == last1) return id;
    return fold_binary_left_nonempty(first1, last1, first2, std::ref(op1), std::ref(op2), std::ref(proj1), std::ref(proj2));
  }
};

export inline constexpr fold_binary_left_impl fold_binary_left{};

struct fold_binary_right_nonempty_impl
{
  template <typename Op1, typename Op2, typename I1, typename I2, typename Proj1, typename Proj2>
  using result_t =
    std::invoke_result_t
    <
      Op1,
      std::invoke_result_t<Op2, projected_value_t<I1, Proj1>, projected_value_t<I2, Proj2>>,
      std::invoke_result_t<Op2, projected_value_t<I1, Proj1>, projected_value_t<I2, Proj2>>
    >;

  template
  <
    std::ranges::bidirectional_range R1,
    std::ranges::bidirectional_range R2,
    typename Op1,
    typename Op2,
    typename Proj1 = std::identity,
    typename Proj2 = std::identity
  >
  requires
    std::regular_invocable
    <
      Op1,
      std::invoke_result_t<Op2, projected_range_value_t<R1, Proj1>, projected_range_value_t<R2, Proj2>>,
      std::invoke_result_t<Op2, projected_range_value_t<R1, Proj2>, projected_range_value_t<R2, Proj2>>
    > &&
    indirectly_regular_binary_invocable
    <
      Op2,
      std::projected<std::ranges::iterator_t<R1>, Proj1>,
      std::projected<std::ranges::iterator_t<R2>, Proj2>
    >
  [[nodiscard]] constexpr auto
  operator()(R1&& r1, R2&& r2, Op1 op1, Op2 op2, Proj1 proj1 = {}, Proj2 proj2 = {}) const
  {
    // pre axiom: "r1 and r2 are non-empty and length of r2 >= length of r1"

    return (*this)(std::ranges::begin(r1), std::ranges::end(r1), std::ranges::begin(r2), std::ranges::end(r2), std::ref(op1), std::ref(op2), std::ref(proj1), std::ref(proj2));
  }

  template
  <
    std::bidirectional_iterator I1,
    std::sentinel_for<I1> S1,
    std::bidirectional_iterator I2,
    std::sentinel_for<I2> S2,
    typename Op1,
    typename Op2,
    typename Proj1 = std::identity,
    typename Proj2 = std::identity
  >
  [[nodiscard]] constexpr auto
  operator()(I1 first1, S1 last1, I2 first2, S2 last2, Op1 op1, Op2 op2, Proj1 proj1 = {}, Proj2 proj2 = {}) const
  requires
    std::regular_invocable
    <
      Op1,
      std::invoke_result_t<Op2, projected_value_t<I1, Proj1>, projected_value_t<I2, Proj2>>,
      std::invoke_result_t<Op2, projected_value_t<I1, Proj1>, projected_value_t<I2, Proj2>>
    > &&
    indirectly_regular_binary_invocable
    <
      Op2,
      std::projected<I1, Proj1>,
      std::projected<I2, Proj2>
    >
  {
    // pre axiom: first1 != last1 && "first2 denotes the start of a range of length >= length of [first1, last1)"

    auto tail1 = std::ranges::next(first1, last1);
    --tail1;
    auto tail2 = std::ranges::next(first2, last2);
    --tail2;
    auto result = std::invoke(op2, std::invoke(proj1, *tail1), std::invoke(proj2, *tail2));
    while (first1 != tail1) {
      --tail1;
      --tail2;
      result = std::invoke(op1, result, std::invoke(op2, std::invoke(proj1, *tail1), std::invoke(proj2, *tail2)));
    }
    return result;
  }
};

export inline constexpr fold_binary_right_nonempty_impl fold_binary_right_nonempty{};

struct fold_binary_right_impl
{
  template <typename Op1, typename Op2, typename I1, typename I2, typename Proj1, typename Proj2>
  using result_t =
    std::invoke_result_t
    <
      Op1,
      std::invoke_result_t<Op2, projected_value_t<I1, Proj1>, projected_value_t<I2, Proj2>>,
      std::invoke_result_t<Op2, projected_value_t<I1, Proj1>, projected_value_t<I2, Proj2>>
    >;

  template
  <
    std::ranges::bidirectional_range R1,
    std::ranges::bidirectional_range R2,
    typename Op1,
    typename Op2,
    typename Proj1 = std::identity,
    typename Proj2 = std::identity
  >
  requires
    std::regular_invocable
    <
      Op1,
      std::invoke_result_t<Op2, projected_range_value_t<R1, Proj1>, projected_range_value_t<R2, Proj2>>,
      std::invoke_result_t<Op2, projected_range_value_t<R1, Proj2>, projected_range_value_t<R2, Proj2>>
    > &&
    indirectly_regular_binary_invocable
    <
      Op2,
      std::projected<std::ranges::iterator_t<R1>, Proj1>,
      std::projected<std::ranges::iterator_t<R2>, Proj2>
    > &&
    std::movable
    <
      result_t
      <
        Op1,
        Op2,
        std::ranges::iterator_t<R1>,
        std::ranges::iterator_t<R2>,
        Proj1,
        Proj2
      >
    >
  [[nodiscard]] constexpr auto
  operator()(R1&& r1, R2&& r2, result_t<Op1, Op2, std::ranges::iterator_t<R1>, std::ranges::iterator_t<R2>, Proj1, Proj2> id, Op1 op1, Op2 op2, Proj1 proj1 = {}, Proj2 proj2 = {}) const
  {
    return (*this)(std::ranges::begin(r1), std::ranges::end(r1), std::ranges::begin(r2), std::ranges::end(r2), std::move(id), std::ref(op1), std::ref(op2), std::ref(proj1), std::ref(proj2));
  }

  template
  <
    std::bidirectional_iterator I1,
    std::sentinel_for<I1> S1,
    std::bidirectional_iterator I2,
    std::sentinel_for<I2> S2,
    typename Op1,
    typename Op2,
    typename Proj1 = std::identity,
    typename Proj2 = std::identity
  >
  [[nodiscard]] constexpr auto
  operator()(I1 first1, S1 last1, I2 first2, S2 last2, result_t<Op1, Op2, I1, I2, Proj1, Proj2> id, Op1 op1, Op2 op2, Proj1 proj1 = {}, Proj2 proj2 = {}) const
  requires
    std::regular_invocable
    <
      Op1,
      std::invoke_result_t<Op2, projected_value_t<I1, Proj1>, projected_value_t<I2, Proj2>>,
      std::invoke_result_t<Op2, projected_value_t<I1, Proj1>, projected_value_t<I2, Proj2>>
    > &&
    indirectly_regular_binary_invocable
    <
      Op2,
      std::projected<I1, Proj1>,
      std::projected<I2, Proj2>
    >
  {
    if (first1 == last1) return id;
    return fold_binary_right_nonempty(first1, last1, first2, last2, std::ref(op1), std::ref(op2), std::ref(proj1), std::ref(proj2));
  }
};

export inline constexpr fold_binary_right_impl fold_binary_right{};

struct reverse_append_impl
{
  template <std::ranges::forward_range R, forward_linker L>
  requires std::same_as<std::ranges::iterator_t<R>, iterator_t<L>>
  constexpr auto
  operator()(R&& r, std::ranges::iterator_t<R> head, L set_successor) const -> std::ranges::iterator_t<R>
  {
    (*this)(std::ranges::begin(r), std::ranges::end(r), head, std::ref(set_successor));
  }

  template <std::forward_iterator I, forward_linker L>
  requires std::same_as<I, iterator_t<L>>
  constexpr auto
  operator()(I first, std::sentinel_for<I> auto last, I head, L set_successor) const -> I
  {
    while (first != last) {
      auto next = first;
      ++next;
      std::invoke(set_successor, first, head);
      head = first;
      first = next;
    }
    return head;
  }
};

export inline constexpr reverse_append_impl reverse_append{};

}
