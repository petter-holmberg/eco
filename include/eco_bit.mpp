module;

#include <cassert>
#include <climits>

#define contract_assert assert

export module eco:bit;

import std;

namespace eco::inline cpp23 {

export template <std::integral T, std::integral U>
[[nodiscard]] constexpr auto
div_ceil(T x, U y) -> std::common_type_t<T, U>
{
  return !!x + ((x - !!x) / y);
}

export template <typename T>
inline constexpr int bit_size_v = CHAR_BIT * sizeof(T);

export template <std::unsigned_integral T>
[[nodiscard]] constexpr auto
bit_read(T x, std::uint8_t i) noexcept -> T
{
  contract_assert(i < bit_size_v<T>);

  return x >> i & 1;
}

export template <std::unsigned_integral T>
[[nodiscard]] constexpr auto
bit_set(T& x, std::uint8_t i) noexcept
{
  contract_assert(i < bit_size_v<T>);

  x |= T{1} << i;
}

export template <std::unsigned_integral T>
[[nodiscard]] constexpr auto
bit_clear(T& x, std::uint8_t i) noexcept
{
  contract_assert(i < bit_size_v<T>);

  x &= ~(T{1} << i);
}

export template <std::unsigned_integral T>
[[nodiscard]] constexpr auto
bit_flip(T& x, std::uint8_t i) noexcept
{
  contract_assert(i < bit_size_v<T>);

  x ^= T{1} << i;
}

export template <std::uint8_t n, std::uint8_t i, std::unsigned_integral T>
requires (n > 0 && i < bit_size_v<T> && i + n <= bit_size_v<T>)
[[nodiscard]] constexpr auto
bits_read(T x) noexcept -> T
{
  if constexpr (n == 1) {
    return x >> i & 1;
  } else {
    return x >> i & ((T{1} << n) - 1);
  }
}

export template <std::uint8_t n, std::unsigned_integral T>
requires (n > 0 && n <= bit_size_v<T>)
[[nodiscard]] constexpr auto
bits_read(T x, std::uint8_t i) noexcept -> T
{
  contract_assert(i < bit_size_v<T>);
  contract_assert(i + n <= bit_size_v<T>);

  if constexpr (n == 1) {
    return x >> i & 1;
  } else {
    return x >> i & ((T{1} << n) - 1);
  }
}

export template <std::unsigned_integral T>
[[nodiscard]] constexpr auto
bits_read(T x, std::uint8_t n, std::uint8_t i) noexcept -> T
{
  contract_assert(n > 0);
  contract_assert(i < bit_size_v<T>);
  contract_assert(i + n <= bit_size_v<T>);

  return x >> i & ((T{1} << n) - 1);
}

export template <std::uint8_t n, std::unsigned_integral T>
requires (n > 0 && n <= bit_size_v<T>)
constexpr void
bits_write(T& x, T value, std::uint8_t i) noexcept
{
  contract_assert(i < bit_size_v<T>);
  contract_assert(i + n <= bit_size_v<T>);

  x &= ~(((T{1} << n) - 1) << i);
  x |= value << i;
}

export template <std::unsigned_integral T>
constexpr void
bits_write(T& x, T value, std::uint8_t n, std::uint8_t i) noexcept
{
  contract_assert(n > 0);
  contract_assert(n <= bit_size_v<T>);
  contract_assert(i < bit_size_v<T>);
  contract_assert(i + n <= bit_size_v<T>);

  x &= ~(((T{1} << n) - 1) << i);
  x |= value << i;
}

export template <std::uint8_t n, std::uint8_t i, std::unsigned_integral T>
requires (n > 0 && n <= bit_size_v<T> && i < bit_size_v<T> && i + n > bit_size_v<T>)
[[nodiscard]] constexpr auto
bits_read_straddled(T x, T y) noexcept -> T
{
  return (x >> i) | (y & ((T{1} << ((i + n) % bit_size_v<T>)) - 1)) << (bit_size_v<T> - i);
}

export template <std::uint8_t n, std::unsigned_integral T>
requires (n > 0 && n <= bit_size_v<T>)
[[nodiscard]] constexpr auto
bits_read_straddled(T x, T y, std::uint8_t i) noexcept -> T
{
  contract_assert(i < bit_size_v<T>);
  contract_assert(i + n > bit_size_v<T>);

  return (x >> i) | (y & ((T{1} << ((i + n) % bit_size_v<T>)) - 1)) << (bit_size_v<T> - i);
}

export template <std::unsigned_integral T>
[[nodiscard]] constexpr auto
bits_read_straddled(T x, T y, std::uint8_t n, std::uint8_t i) noexcept -> T
{
  contract_assert(n > 0);
  contract_assert(n <= bit_size_v<T>);
  contract_assert(i < bit_size_v<T>);
  contract_assert(i + n > bit_size_v<T>);

  return (x >> i) | (y & ((T{1} << ((i + n) % bit_size_v<T>)) - 1)) << (bit_size_v<T> - i);
}

export template <std::uint8_t n, std::unsigned_integral T>
requires (n > 1 && n <= bit_size_v<T>)
constexpr void
bits_write_straddled(T& x, T&y, T value, std::uint8_t i) noexcept
{
  contract_assert(i < bit_size_v<T>);
  contract_assert(i + n > bit_size_v<T>);

  x = (x & ((T{1} << i) - 1)) | (value << i);
  y = (y & ~((T{1} << ((i + n) % bit_size_v<T>)) - 1)) | (value >> (bit_size_v<T> - i));
}

export template <std::unsigned_integral T>
constexpr void
bits_write_straddled(T& x, T&y, T value, std::uint8_t n, std::uint8_t i) noexcept
{
  contract_assert(n > 1);
  contract_assert(n <= bit_size_v<T>);
  contract_assert(i < bit_size_v<T>);
  contract_assert(i + n > bit_size_v<T>);

  x = (x & ((T{1} << i) - 1)) | (value << i);
  y = (y & ~((T{1} << ((i + n) % bit_size_v<T>)) - 1)) | (value >> (bit_size_v<T> - i));
}

}
